# -*- coding: utf-8 -*-
"""3L-CSMA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wA8BM1bqJuUEIF57tXEot0HlMyzKa6tU
"""

class ChaoticSMA(Root):
    ID_WEI = 2

    #def __init__(self, obj_func=None, lb=None, ub=None, dim=50, verbose=True, Max_iter=750, population=100, z=0.03):
    def __init__(self, obj_func, lb, ub, dim, verbose, Max_iter, population, chaos_index, z=0.03):
        Root.__init__(self, obj_func, lb, ub, dim, verbose)
        self.Max_iter = Max_iter
        self.population = population
        self.z = z

    def create_solution(self, minmax=0):
        pos = np.random.uniform(self.lb, self.ub)
        fit = self.get_fitness_position(pos)
        weight = np.zeros(self.dim)
        return [pos, fit, weight]

    def train(self):
        iteration_wise_fitness=[]
        pop = [self.create_solution() for _ in range(self.population)]
        pop, g_best = self.get_sorted_pop_and_global_best_solution(pop, self.ID_FIT, self.ID_MIN_PROB)      # Eq.(2.6)

        for Max_iter in range(self.Max_iter):

            s = pop[0][self.ID_FIT] - pop[-1][self.ID_FIT] + self.EPSILON       # plus eps to avoid denominator zero

            # calculate the fitness weight of each slime mold
            for i in range(0, self.population):
                # Eq.(2.5)
                if i <= int(self.population / 2):
                    pop[i][self.ID_WEI] = 1 + chaos(chaos_index, 0.7, self.dim) * np.log10((pop[0][self.ID_FIT] - pop[i][self.ID_FIT]) / s + 1)
                else:
                    pop[i][self.ID_WEI] = 1 - chaos(chaos_index, 0.7, self.dim) * np.log10((pop[0][self.ID_FIT] - pop[i][self.ID_FIT]) / s + 1)

            a = np.arctanh(-((Max_iter + 1) / self.Max_iter) + 1)                        # Eq.(2.4)
            b = 1 - (Max_iter + 1) / self.Max_iter

            # Update the Position of search agents
            for i in range(0, self.population):
                if np.random.uniform() < self.z:                                          # Eq.(2.7)
                    pop[i][self.ID_POS] = np.random.uniform(self.lb, self.ub)
                else:
                    p = np.tanh(np.abs(pop[i][self.ID_FIT] - g_best[self.ID_FIT]))    # Eq.(2.2)
                    vb = np.random.uniform(-a, a, self.dim)                      # Eq.(2.3)
                    vc = np.random.uniform(-b, b, self.dim)
                    for j in range(0, self.dim):
                        # two positions randomly selected from population
                        id_a, id_b = np.random.choice(list(set(range(0, self.population)) - {i}), 2, replace=False)
                        if np.random.uniform() < p:  # Eq.(2.1)
                            pop[i][self.ID_POS][j] = g_best[self.ID_POS][j] + vb[j] * (
                                        pop[i][self.ID_WEI][j] * pop[id_a][self.ID_POS][j] - pop[id_b][self.ID_POS][j])
                        else:
                            pop[i][self.ID_POS][j] = vc[j] * pop[i][self.ID_POS][j]

            # Check bound and re-calculate fitness after the whole population move
            for i in range(0, self.population):
                pos_new = self.amend_position(pop[i][self.ID_POS])
                fit_new = self.get_fitness_position(pos_new)
                pop[i][self.ID_POS] = pos_new
                pop[i][self.ID_FIT] = fit_new

            # Sorted population and update the global best
            pop, g_best = self.update_sorted_population_and_global_best_solution(pop, self.ID_MIN_PROB, g_best)
            iteration_wise_fitness.append(g_best[1]) ###
            self.loss_train.append(g_best[self.ID_FIT])
            #if self.verbose:
                #print("> Max_iter: {}, Best fit: {}".format(Max_iter + 1, g_best[self.ID_FIT]))
        self.solution = g_best
        return g_best[self.ID_POS], g_best[self.ID_FIT], self.loss_train, iteration_wise_fitness ###